# ====== Rules for creating bedgraphs files from aligned reads ===================


# Create bedgraphs using single bp read coordinates 
# Do not reverse strands since read #1 from QIA-seq libraries is the sense
# direction
rule create_bedgraphs:
    input:
        PROJ + "/beds/{sam_grp}.bed.gz"
    output:
        p_bg   = temp(PROJ + "/bg/{sam_grp}_pos.bedgraph.gz"),
        n_bg   = temp(PROJ + "/bg/{sam_grp}_neg.bedgraph.gz")
    params:
        job_name = "{sam_grp}_bedgraph",
        memory   = 8,
        chroms   = CHROMS
    log:
        out = PROJ + "/logs/{sam_grp}_bedgraph.out",
        err = PROJ + "/logs/{sam_grp}_bedgraph.err"
    benchmark:
        PROJ + "/benchmarks/{sam_grp}_bedgraph.tsv"
    message:
        "Creating bedgraphs for {wildcards.sam_grp}"
    threads:
        6
    shell:
        """
        create_bedgraph() {{
            local reads=$1
            local strand=$2
            local mtplyr=$3
            local bg=$4

            tmp_1=$(mktemp tmp.XXXXX)
            tmp_2=$(mktemp tmp.XXXXX)

            zcat -f $reads \
                > $tmp_1

            cat $tmp_1 \
                | sort -S1G --parallel={threads} -k1,1 -k2,2n \
                | bedtools genomecov -bg $strand -i - -g {params.chroms} \
                > $tmp_2
            
            cat $tmp_2 \
                | pigz -p {threads} \
                > $bg

            rm $tmp_1 $tmp_2
        }}
        
        # Create bedgraphs for each strand
        # Normalized by the number of reads in the starting bed file (RPM)
        create_bedgraph \
            {input} \
            "-strand +" \
            1 \
            {output.p_bg} 

        create_bedgraph \
            {input} \
            "-strand -" \
            -1 \
            {output.n_bg} 
        """


# Check that bedgraphs for subsampling regions have the same number of counts
# for each gene
rule gene_subsample_test:
    input:
        pos = lambda wildcards: expand(
            PROJ + "/bg/{sample}_{{group}}_{{sub_region}}_pos.bedgraph.gz",
            sample = SAMPLES[wildcards.group]
        ),
        neg = lambda wildcards: expand(
            PROJ + "/bg/{sample}_{{group}}_{{sub_region}}_neg.bedgraph.gz",
            sample = SAMPLES[wildcards.group]
        )
    output:
        PROJ + "/stats/{group}_{sub_region}_test.tsv"
    params:
        job_name = "{group}_{sub_region}_test",
        memory   = 4,
        genes    = TEST_GENES
    log:
        out = PROJ + "/logs/{group}_{sub_region}_test.out",
        err = PROJ + "/logs/{group}_{sub_region}_test.err"
    benchmark:
        PROJ + "/benchmarks/{group}_{sub_region}_test.tsv"
    message:
        "Testing subsampling for {wildcards.group} {wildcards.sub_region}"
    threads:
        1
    shell:
        """
        check_sampling() {{
            local bgs=($1)
            local genes="$2"
            local out="$3"
        
            local test_res=${{bgs[@]/%/.TEST}}
        
            for bed in ${{bgs[@]}}
            do
                local res="$bed.TEST"
        
                zcat "$bed" \
                    | awk -v OFS="\t" '{{
                        $4 = $4 * ($3 - $2);
                        print
                    }}' \
                    | bedtools map -a "$genes" -b - -c 4 -o sum \
                    | awk -v OFS="\t" '$6 == "+" {{gsub(".", 0, $7); print}}' \
                    > "$res"
            done
        
            local chk=$(md5sum ${{test_res[@]}} | sort -k1,1 -u | wc -l)
        
            rm ${{test_res[@]}}
        
            if [[ "$chk" == 1 ]]
            then
                local res='PASS'
            else
                local res='FAIL'
            fi
        
            for file in ${{bgs[@]}}
            do
                echo -e "$file\t{wildcards.group}\t{wildcards.sub_region}\t$res" \
                    >> "$out"
            done
        }}

        check_sampling "{input.pos}" {params.genes} {output}
        check_sampling "{input.neg}" {params.genes} {output}
        """


 
