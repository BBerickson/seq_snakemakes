# Create bed files for RNA 3' end
rule beds:
    input:
        PROJ + "/bams/{sample}_" + INDEX_SAMPLE + "_" + SEQ_DATE + ".bam",
        expand(SRC + "/{script}", script = SCRIPTS)
    output:
        bed    = temp_fn(PROJ + "/beds/{sample}.bed.gz"),
        shift  = PROJ + "/beds/{sample}_shift.bed.gz",
        nofilt = PROJ + "/beds/{sample}_nofilt.bed.gz",
        stats  = temp(PROJ + "/stats/{sample}_filt_stats.tsv")
    params:
        job_name = "{sample}_create_beds",
        genes    = GENES,
        mask     = MASK,
        orientation = ORIENTATION
    resources:
        memory   = lambda wildcards, input: memory_estimator(input, 0.2, 3)
    log:
        out = PROJ + "/logs/{sample}_beds.out",
        err = PROJ + "/logs/{sample}_beds.err"
    benchmark:
        PROJ + "/benchmarks/{sample}_beds.tsv"
    threads:
        12
    shell:
       """
         # Create bed file for aligned reads
         bamToBed -i {input[0]} \
             | awk -v OFS="\t" -v sam='{wildcards.sample}' '{{
                 if ($1 !~ "^chr") {{
                     $1 = "chr"$1
                 }};
                 count += 1;
                 print $0, $3 - $2
             }} END {{
                 print sam, "Aligned reads", count \
                     > "{output.stats}"
             }}' \
             | sort -S1G --parallel={threads} -k1,1 -k2,2n \
             | bedtools intersect -sorted -v  -a - -b {params.mask} \
             | sort -S1G --parallel={threads} -k1,1 -k2,2n \
             | pigz -p {threads} \
             > '{output.bed}'
  
         # Filter for reads that are within params.gene and not within
         # params.mask
         # * This filtering is not strand specific
         # * Collapse read coordinates to the RNA 3' end.
         zcat '{output.bed}' \
             | bedtools intersect -sorted -wa -a - -b {params.genes} \
             | awk -v OFS="\t" -v sam='{wildcards.sample}' -v ORIENTATION="{params.orientation}" '{{
                 if (ORIENTATION == "R2") {{
                    if ($6 == "+") {{
                        $3 = $2 + 1;
                        $6 = "-"
                    }} else {{
                        $2 = $3 - 1;
                        $6 = "+"
                    }};
                 }} else {{
                    if ($6 == "+") {{
                        $2 = $3 - 1;
                     }} else {{
                         $3 = $2 + 1;
                     }};
                 }}
                 count += 1;
                 print
             }} END {{
                 print sam, "Filtered reads", count \
                     >> "{output.stats}";
             }}' \
             | sort -S1G --parallel={threads} -k1,1 -k2,2n \
             | pigz -p {threads} \
             > '{output.shift}'
  
         zcat '{output.bed}' \
             | awk -v OFS="\t" -v ORIENTATION="{params.orientation}" '{{
                 if (ORIENTATION == "R2") {{
                    if ($6 == "+") {{
                        $3 = $2 + 1;
                        $6 = "-"
                    }} else {{
                        $2 = $3 - 1;
                        $6 = "+"
                    }};
                 }} else {{
                    if ($6 == "+") {{
                        $2 = $3 - 1;
                     }} else {{
                         $3 = $2 + 1;
                     }};
                 }}
                 print
             }}' \
             | sort -S1G --parallel={threads} -k1,1 -k2,2n \
             | pigz -p {threads} \
             > '{output.nofilt}'
       """


# Create filtering summary
rule filt_summary:
    input:
        expand(
            PROJ + "/stats/{sample}_filt_stats.tsv",
            sample = SAMS_UNIQ
        )
    output:
        PROJ + "/stats/"+ PROJ + "_filt.tsv"
    params:
        job_name = PROJ + "_filt_summary"
    resources: 
        memory   = 4
    log:
        out = PROJ + "/logs/" + PROJ + "_filt_summary.out",
        err = PROJ + "/logs/" + PROJ + "_filt_summary.err"
    threads:
        1
    shell:
        """
          file_arr=({input})
  
          for file in ${{file_arr[@]}}
          do
              cat "$file" \
                  >> '{output}'
          done
        """
