# ====== Rules for makeing bigwig covarge files with bamCoverage  =================================

# Align trimmed reads with bamCoverage
rule bamCoverage:
    input:
        bam = lambda wildcards: expand(
            PROJ + "/" + BAM_PATH + "/{sample}_aligned_{index}_" + SEQ_DATE + ".bam",
            sample = SAMPLES[wildcards.newnam],
            index = [wildcards.index]
        ),
        check_point = PROJ + "/report/" + PROJ + "_results.tsv",
        norm_files = lambda wildcards: [
            PROJ + "/stats/" + sample + "_summary_featureCounts.tsv" 
            for sample in SAMPLES[wildcards.newnam]
        ]
    output:
        bigwig  = PROJ + "/bw/{newnam}_aligned_{index}_" + SEQ_DATE + "_norm_{suffix}.bw"
    params:
        job_name = "{newnam}_aligned_{index}_" + SEQ_DATE + "_{suffix}_bamCoverage",
        args     = CMD_PARAMS["bamCoverage"] + CMD_PARAMS.get("bamCoverageBL", ""),
        scale    = lambda wildcards, input: _get_norm(
            DF_SAM_NORM, 
            wildcards.newnam, 
            wildcards.suffix, 
            wildcards.index,
            input.norm_files
        )
    resources:
        memory   = lambda wildcards, input: memory_estimator(input.bam, 0.2, 5)
    log:
        out = PROJ + "/logs/{newnam}_aligned_{index}_" + SEQ_DATE + "_{suffix}_bamCoverage.out",
        err = PROJ + "/logs/{newnam}_aligned_{index}_" + SEQ_DATE + "_{suffix}_bamCoverage.err"
    threads: 
        12
    shell:
        """
        bamCoverage \
          -b {input.bam[0]} \
          -of bigwig \
          -o {output.bigwig} \
          {params.args} \
          {params.scale} \
          -p {threads}
        """ 
        

